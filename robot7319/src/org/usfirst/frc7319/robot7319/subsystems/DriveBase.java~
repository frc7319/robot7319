// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc7319.robot7319.subsystems;

import org.usfirst.frc7319.robot7319.RobotMap;
import org.usfirst.frc7319.robot7319.commands.*;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveBase extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Encoder driveBaseleftEnc = RobotMap.driveBasedriveBaseleftEnc;
    private final Encoder driveBaserightEnc = RobotMap.driveBasedriveBaserightEnc;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

	/**Manually adding CANTalons**/
	private final CANTalon leftMotor1 = RobotMap.leftMotor1;
    private final CANTalon leftMotor2 = RobotMap.leftMotor2;
    private final CANTalon rightMotor1 = RobotMap.rightMotor1;
    private final CANTalon rightMotor2 = RobotMap.rightMotor2;
    
    /**DriveBase Specs**/
    private final double DEADZONE = .05;
    private final double WHEEL_DIA = 3.9; //CHANGE LATER ACCORDING TO WHEEL DIAMETER
    private final double CUBIC_SCALE = .02; //CHANGE LATER ACCORDING TO DRIVER PREFERENCE
    private final double PRECISION = 3;
    
    /**Default Inversion**/
    private boolean leftInverted = true;
    private boolean rightInverted = false;
    
    /**Precision and Orientation variables**/
    private boolean isPrecision = false;
    private boolean isOrientationSwap = false;
    
    /**DriveBase constructor**/
    public DriveBase() {
    	leftMotor1.setInverted(leftInverted);
    	leftMotor2.setInverted(leftInverted);
    	rightMotor1.setInverted(rightInverted);
    	rightMotor2.setInverted(rightInverted);
    	
    	leftMotor2.changeControlMode(CANTalon.TalonControlMode.Follower);
    	rightMotor2.changeControlMode(CANTalon.TalonControlMode.Follower);
    	
    	leftMotor2.set(leftMotor1.getDeviceID());
    	rightMotor2.set(rightMotor1.getDeviceID());
    	
    	leftMotor1.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
    	rightMotor1.changeControlMode(CANTalon.TalonControlMode.PercentVbus); 
    	
    	leftMotor1.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        rightMotor1.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        	
        leftMotor1.configNominalOutputVoltage(+0f, -0f);
        rightMotor1.configNominalOutputVoltage(+0f, -0f);
        	
        leftMotor1.configPeakOutputVoltage(+12.0f, -12.0f);
        rightMotor1.configPeakOutputVoltage(+12.0f, -12.0f);
        
        leftMotor1.configEncoderCodesPerRev(360);
        rightMotor1.configEncoderCodesPerRev(360);
    }
    
    /**Deadzone Method**/
    public double deadzone(double input, double deadVal)
    {
    	if(Math.abs(0 - input) <= deadVal) return 0;
    	else return input;
    }
    
    /**Cubic Scaling**/
    public double cubicScale(double in, double cubic)
    {
    	return cubic * in + (1 - cubic) * Math.pow(in, 3);
    }
    
    /**Basic Drive ->
       Just for setting values to the DriveBase motors*/ 
    public void BasicDrive(double left, double right)
    {
    	leftMotor1.set(left);
    	rightMotor1.set(right);
    }
    
    /**Cubic Drive ->
       Simple Tank drive with:
           -Cubic scale
       	   -deadzone correction on the joystick*/
    public void cubicDrive(double left, double right)
    {
    	if(isOrientationSwap)
    	{
    		if(isPrecision)
    		{
    			leftMotor1.set(cubicScale(deadzone(right,DEADZONE),CUBIC_SCALE) / PRECISION);
    			rightMotor2.set(cubicScale(deadzone(left,DEADZONE),CUBIC_SCALE) / PRECISION);
    		}
    		else
    		{
    			leftMotor1.set(cubicScale(deadzone(right,DEADZONE),CUBIC_SCALE));
    			rightMotor2.set(cubicScale(deadzone(left,DEADZONE),CUBIC_SCALE));
    		}
    	}
    	else
    	{
    		if(isPrecision)
    		{
    			leftMotor1.set(cubicScale(deadzone(left,DEADZONE),CUBIC_SCALE) / PRECISION);
    			rightMotor2.set(cubicScale(deadzone(right,DEADZONE),CUBIC_SCALE) / PRECISION);
    		}
    		else
    		{
    			leftMotor1.set(cubicScale(deadzone(left,DEADZONE),CUBIC_SCALE));
    			rightMotor2.set(cubicScale(deadzone(right,DEADZONE),CUBIC_SCALE));
    		}
    	}
    }
    
    /**Arcade Drive ->
       Arcade Drive with:
           -out of bounds correction
           -cubic scale
           -deadzone correction on the joystic**/
    public void arcadeDrive(double left, double right)
    {
    	double tempL = cubicScale(deadzone(left,DEADZONE),CUBIC_SCALE)-cubicScale(deadzone(right,DEADZONE),CUBIC_SCALE);
    	double tempR = cubicScale(deadzone(left,DEADZONE),CUBIC_SCALE)+cubicScale(deadzone(right,DEADZONE),CUBIC_SCALE);
    	
    	if(tempL > 1)
    	{
    		tempR -= tempL - 1;
    		tempL = 1;
    	}
    	else if(tempR > 1)
    	{
    		tempL -= tempR - 1;
    		tempR = 1;
    	}
    	
    	if(tempL < -1)
    	{
    		tempR -= tempL + 1;
    		tempL = -1;
    	}
    	else if(tempR < -1)
    	{
    		tempL -= tempR + 1;
    		tempR = -1;
    	}
    	
    	if(isOrientationSwap)
    	{
    		if(isPrecision)
    		{
    			leftMotor1.set(tempR / PRECISION);
    			rightMotor2.set(tempL / PRECISION);
    		}
    		else
    		{
    			leftMotor1.set(tempR);
    			rightMotor2.set(tempL);
    		}
    	}
    	else
    	{
    		if(isPrecision)
    		{
    			leftMotor1.set(tempL / PRECISION);
    			rightMotor2.set(tempR / PRECISION);
    		}
    		else
    		{
    			leftMotor1.set(tempL);
    			rightMotor2.set(tempR);
    		}
    	}
    }
	
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}

